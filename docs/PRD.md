好，那我把之前聊过的思路「收束」成一份**完整设计方案**，你可以直接当成产品/技术设计文档的骨架来用（不含任何伪代码）。

下面的设计默认你是技术背景（PM+工程），所以会从：**目标 → 功能 → 智能体角色 → 流程 → 数据结构 → 技术选型** 这样来展开。

------

## 一、产品定位与目标

### 1.1 产品一句话描述

> 一个面向开发者的「**开源项目学习教练 AI 智能体**」，
>  能基于任意代码仓库，结合你的学习目标，
>  用**问题驱动 + 架构分析 + 代码讲解 + 能力模块深挖**的方式，
>  让你在有限时间内真正吃透一个项目，而不是在源码里瞎游。

### 1.2 关键价值（给用户的）

- **从“代码海洋”变成“学习路线”**：
   不再自己瞎点文件，而是有清晰的阶段（整体架构 → 模块 → 核心类/方法 → 设计亮点）。
- **支持「只看几个能力模块」的深挖学习**：
   比如只看：Agent Harness、插件系统、缓存层、错误处理等。
- **结构化输出**：
   自动形成一份结构化的项目分析文档（整体架构、模块职责、核心类、关键流程、最佳实践），你可以直接用来复盘或分享。
- **提升代码能力而不是只记用法**：
   通过类似「Socratic Tutor」的问答方式，先让你自己解释，再由系统纠偏，这种方式在编程教育研究中已经被证明能显著提高代码理解能力。

------

## 二、核心能力与功能模块

### 2.1 两种学习模式

1. **全局模式（Macro Learning）**
   - 目标：快速建立对项目的整体心智模型。
   - 输出：
     - 整体架构图 + 模块划分
     - 核心入口 & 数据流
     - 主要核心流程（启动 / 请求 /任务）
     - 结构化分析文档（后面细说）
2. **能力模块模式（Capability Deep Dive）**
   - 目标：只挑几个能力模块深入学习、提升“代码能力”。
   - 用户可以勾选：
     - 插件 / 扩展系统
     - Agent Harness / Workflow / 状态机
     - 缓存层 / 数据访问层
     - 鉴权 / 错误处理 / 观察性（日志/指标）
   - 输出：
     - 针对该模块的 mini 架构分析 + 核心类/方法 + 调用链
     - 模块内设计亮点 & 可迁移到自己项目的实践建议

### 2.2 智能体自动生成的分析内容（你列的九大块）

为任何项目，智能体围绕下面**统一模版**生成分析 + 互动教学：

1. **整体架构分析**
2. **各模块职责与内部关系**
3. **核心类解剖**
4. **关键方法深度解析**
5. **模块间调用依赖关系分析**
6. **核心流程分析**
7. **项目的核心入口 & 主要数据流**
8. **设计亮点与精妙之处**
9. **从源码看最佳实践（工程 & 代码风格）**

这些不会是「一次性吐给你一篇大作文」，而是：

- 系统先自动生成一版**初稿分析文档**；
- Tutor 智能体再按章节出题，让你自我解释 → 再对照这份分析和实际代码帮你纠偏。

------

## 三、智能体整体架构设计

### 3.1 三层结构

1. **交互层（UI / 插件）**
   - Web 页面 / VS Code 插件 / CLI
   - 核心视图：
     - 对话区（Tutor 对话）
     - 问题列表 & 学习阶段
     - 能力模块选择面板
     - 生成的分析文档和笔记
2. **智能体编排层（Orchestrator）**
   - 使用 LangGraph 等框架管理状态和多子智能体流程：支持状态持久化、多智能体协作、循环/分支等。
   - 或在此之上用 deepagents 做「agent harness」，利用其中间件（规划工具、文件系统、subagents）简化实现。
3. **工具 & 数据层**
   - Git + 文件系统访问
   - 代码索引 & 搜索（关键词 + 向量）
   - 项目画像（ProjectProfile）
   - 学习记录 & 分析文档存储

### 3.2 关键子智能体（Agent 角色）

至少包括：

1. **Project Profiler（项目画像器）**
   - 输入：Repo URL / 本地路径
   - 功能：
     - 克隆/加载仓库
     - 分析语言 / 主要依赖 / 框架特征
     - 扫描目录结构，识别：入口、API 层、业务层、存储层、配置等
   - 输出：`ProjectProfile`（JSON）
2. **Repo Mapper（代码地图生成器）**
   - 功能：
     - 构建 `RepoMap`：模块列表、主要文件、核心类、关键方法、入口函数等
     - 标注「能力模块候选」：例如缓存、鉴权、Agent Harness、插件系统（通过命名 / 文件路径 / 依赖模式识别）
   - 输出：`RepoMap + CapabilityCandidates`
3. **Question Planner（问题规划器）——这是核心**
   - 功能：
     - 根据 `ProjectProfile + RepoMap + 用户学习目标 + 选中的能力模块`
     - 从问题模版库中选取、实例化问题，生成一张「问题图」（Question Graph）
       - 每个问题包含：标题、描述、所需模块、推荐查看文件、难度、前置依赖
   - 思想上类似“基于代码自动生成苏格拉底式对话”的研究，但我们是针对项目理解。
4. **Analysis Generator（分析文档生成器）**
   - 功能：
     - 按统一模版（你列的那 9 个部分）＋ `ProjectProfile/RepoMap`
     - 自动生成一版**结构化分析草稿**（例如 `/analysis/overview.md`）
     - 用作后续教学的“老师讲义”
5. **Tutor / Coach（学习教练智能体）**
   - 功能：
     - 驱动学习流程：选择下一个要问的问题（Question Graph）
     - 先问你，让你自我解释（self-explanation），再评估和纠偏，这种方式在编程教育里被证实能显著提升代码理解。
     - 控制何时引用 Analysis Generator 的结论，避免一上来就给答案。
6. **Explainer（代码讲解智能体）**
   - 功能：
     - 将问题 + 相关代码片段 → 生成标准讲解
     - 必须基于检索到的代码 / 分析草稿，而不是凭空胡编（通过 RAG + 强提示约束）
     - 输出时带上文件路径和函数名，方便你在 IDE/浏览器中定位
7. **Note & Progress Manager（笔记与进度管理）**
   - 功能：
     - 把每道题的：问题、你的答案、系统总结、相关代码位置 → 写入笔记
     - 跟踪：学习阶段、已完成问题、已精读模块
     - 长期记忆：为每个仓库+用户存一份学习档案，后续再来可以接着学
8. **Capability Specialist Agents（能力模块专家子智能体，可选扩展）**
   - 针对特定能力模块（如 Agent Harness、RAG pipeline、插件系统）定义专门的子智能体：
     - 有更细的模版问题
     - 能识别更深的模式和最佳实践
   - 使用类似 deepagents 的 SubAgent 机制来做调用和上下文隔离。

------

## 四、问题系统（Question System）设计

### 4.1 问题模版库（Question Template Library）

按**项目 archetype** 分类，例如：

- `web_backend`
- `library`
- `agent_framework`
- `rag_system`
- `frontend_spa`

每类 archetype 下都有一组问题模版，覆盖你关注的九个维度，比如 `agent_framework` 会包含：

- 系统提示如何组合？（Prompt Composition）
- 内置工具 `write_todos` / 文件系统工具如何注入？（Tool Injection）
- `task` 工具如何识别并调度 subagents？（Subagent Delegation）
- 如何把这些配置最终编译成 LangGraph 的 `StateGraph` / agent runtime？（Runtime Integration）

模版中带占位符，如 `{files}`、`{entry_fn}`、`{module_name}` 等。

### 4.2 问题实例化（针对具体仓库）

Question Planner 会：

1. 用 Repo Mapper 提供的候选信息（入口文件 / 主要模块 / 核心类等）；
2. 将模版“具象化”，变成对你来说更具体的问题，例如：

> 「在 `agent_factory.py` 和 `middleware/prompt_injection.py` 里，系统提示是如何从基础 prompt、用户 prompt 以及中间件说明拼接成最终 prompt 的？请指出关键函数和调用顺序。」

而不是「系统提示在哪组合」这种太抽象的问题。

### 4.3 Question Graph（问题图）

- 节点：具体问题（已实例化）
- 边：前置依赖关系（例如先有整体架构，才能讲模块间依赖）
- 每个节点挂载：
  - 阶段（架构 / 模块 / 核心类 / 设计亮点…）
  - 能力模块标签（如 `AgentHarness`, `PluginSystem`）
  - 推荐要看的文件/路径

Tutor 会根据：

- 你的当前阶段
- 已完成的问题
- 你的回答质量（系统评估）

动态选择下一道题。

------

## 五、分析文档（Project Analysis）设计

### 5.1 统一模版结构

对每个项目生成一份结构化分析文档（Markdown / HTML），基础结构就是你给的那套：

1. 整体架构分析
2. 各模块职责与内部关系
3. 核心类解剖
4. 关键方法深度解析
5. 模块间调用依赖关系分析
6. 核心流程分析
7. 核心入口 & 主要数据流
8. 设计亮点与精妙之处
9. 从源码看最佳实践

### 5.2 自动生成 vs 互动完善

1. **Analysis Generator 自动生成“初稿”**：
   - 基于 `ProjectProfile + RepoMap + 代码检索` + LLM
   - 形成一个“老师讲义”级别的文档，但先不直接全部展示。
2. **Tutor 分章节带你过一遍**：
   - 进入「整体架构分析」章节时：
     - 先问你：「你自己现在看下来，这个项目的主要模块是什么？各自负责什么？」
     - 收到你的回答后，用 Explainer + initial analysis 校对，并展示该章节的精简版结论。
   - 如此对每一章（核心类、关键方法、流程、设计亮点等）重复。
3. **最终产物**：
   - 一份「你参与过、经过问答打磨的分析文档」
   - 附带你的自我解释记录 & 系统纠偏版本 —— 非常适合复习 / 分享 / 写文章。

------

## 六、「只挑能力模块提升代码能力」的具体设计

### 6.1 能力模块识别（Capability Detection）

Repo Mapper 通过以下线索识别能力模块候选：

- 文件/目录命名：如 `plugins/`, `extensions/`, `auth/`, `cache/`, `workflow/`, `graph/`
- 框架特定模式：Spring Security、middleware 管道、事件总线等
- 依赖：如 redis/memcached（缓存），某些 Agent/Workflow 库（LangGraph、Temporal 等）

生成一份 `CapabilityList`，每一项包含：

- 能力名称（插件系统、Agent Harness、缓存层…）
- 涉及的目录/文件/类/配置

### 6.2 用户选择能力模块

在 UI 上：

- 让用户在 CapabilityList 上多选：
  - ✓ Agent Harness
  - ✓ 插件系统
  - ✗ 数据存储层
  - ✓ 错误处理

Question Planner 与 Analysis Generator 会在后续所有阶段：

- 优先针对这些能力模块生成问题 & 分析；
- 其他模块只做必要级别的“为理解这些能力模块服务”的说明。

### 6.3 对每个能力模块的专用输出

例如选择了「Agent Harness」：

- 分析文档里会有专章：
  - Agent Harness 在整体架构中的位置
  - 核心类（如 `AgentRuntime`, `TaskExecutor` 等）的职责
  - 关键方法的调用链（从任务输入到工具调用、子 agent 调度）
  - 与 LangGraph / deepagents / middleware 的集成点
- 问题图里会有一串相关问题，引导你一步步搞清楚这一块；
- Tutor 会在这一章节中更强调「模式抽象」和「可以迁移到自己项目里的设计」。

------

## 七、学习流程（User Journey）总览

### Step 1：创建学习任务

- 你输入 GitHub URL / 选本地目录
- 勾选学习目标（架构 / 能力模块 / 准备二开）
- 选择想深挖的能力模块（可选）

### Step 2：系统预处理（自动）

- Project Profiler → `ProjectProfile`
- Repo Mapper → `RepoMap + CapabilityList`
- Question Planner → `QuestionGraph`
- Analysis Generator → `Initial Analysis Doc`

### Step 3：展示学习面板

UI 中：

- 左：学习阶段 + 问题列表 / 能力模块导航
- 右：对话区（Tutor）、推荐查看文件、当前小节摘要

### Step 4：问题驱动的学习循环

对于每一个问题：

1. Tutor 提问（基于 QuestionGraph）
2. 你在 IDE 或 UI 中查看代码 → 回答（自我解释）
3. Explainer + Analysis 对照代码生成标准讲解
4. Tutor 结合你的回答指出：
   - 哪些正确
   - 哪些不完整/错误
   - 推荐你再查看的代码位置
5. Note Manager 记录整个过程并更新进度

### Step 5：阶段性回顾 & 设计亮点评审

- 每完成一个大章节（架构/模块/能力模块）：
  - 系统自动生成该章节的总结，并与你一起回顾。
  - 特别标记：
    - 精妙设计点
    - 值得借鉴的工程实践 / 代码模式
- 你可以选择导出：
  - 完整项目分析文档
  - 某能力模块的专题分析
  - 自己的 QA + 系统回答作为学习日志

------

## 八、技术选型与实现建议（不含代码）

### 8.1 智能体/流程编排

- 在此基础上用 deepagents 做「深度智能体底座」：
  - 内建 TodoListMiddleware（规划工具）
  - FilesystemMiddleware（虚拟文件系统 + 长期记忆）
  - SubAgentMiddleware（子智能体调度）

### 8.2 LLM 能力

- 一个通用模型：用来做理解、讲解、问答、生成问题。
- 如果用较新模型（如 GPT-4.1 级别或同档），可以支撑复杂指令、长上下文。
- 对问题系统可参考 Socratic tutoring / TreeInstruct 这类方法：用多轮规划 + 层级问题树来构造问题序列。

### 8.3 代码索引与检索

- 语义检索：按文件/函数粒度生成向量；选择合适的 embedding 模型（可以和 LangChain 的 RAG 组件配合）。
- 关键字/结构检索：基于 ripgrep / tree-sitter 等工具做符号级搜索。

### 8.4 存储

- 学习任务、问题图、分析文档、笔记、进度 → 关系型或文档型数据库皆可。
- 代码本身存在 workspace（本地或对象存储），路径/版本信息存库。

------

## 九、你实现时可以优先从哪几块下手

1. **最小闭环 v0**
   - 只做：
     - Project Profiler + Repo Mapper（简易）
     - 一小套手写问题模版（针对 1 种 archetype，比如 web backend 或 agent framework）
     - Tutor 简单问答 + Explainer 基于代码检索的讲解
     - 生成一个简化版分析文档（比如只有：架构 / 核心入口 / 主流程）
2. **迭代 v1**
   - 加：能力模块选择 + 能力模块专用问题模版
   - 加：完整九大分析章节
3. **迭代 v2**
   - 引入多子智能体角色化（Question Planner / Tutor / Explainer 独立）
   - 引入更强的 Socratic 策略（根据用户回答动态调整问题图）

------

这份设计已经把我们之前所有讨论点「编译」成了一个完整的产品 + 技术架构蓝图，你可以：

- 直接按模块拆成需求文档 / backlog；
- 或者选一个你最熟悉的项目（比如 deepagents 本身），用这套设计先做一个 **“只支持 agent 框架” 的 MVP**。

如果你想，下一步我可以帮你把「问题模版库 + 分析文档模版」单独拆出来写成可维护的规范（字段说明、示例），方便你和团队分工：有人做问题设计，有人做系统实现。
